/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package intro_v1;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;
import java.util.StringTokenizer;

import jxl.Workbook;
import jxl.WorkbookSettings;
import jxl.write.WritableCellFormat;
import jxl.write.WritableFont;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;
import jxl.write.WriteException;
import jxl.write.biff.RowsExceededException;

/**
 *
 * @author fer_h
 */
public class Intro_v1 
{

    /**
     * @param args the command line arguments
     */
    public static Intro_v1 g = new Intro_v1();
    public static void main(String[] args) throws IOException 
    {
        //Se declaran variables y clases
        //File localiza el archivo de texto que sera leido
        File archivo = new File("C:\\Users\\"+System.getProperty("user.name")+"\\Desktop\\Texto.txt");
        //File Reader lee el archivo
        FileReader fr = new FileReader(archivo);
        //Buffered Reader lee entrada de texto
        BufferedReader br = new BufferedReader(fr);
        
        //Declarar variables
        //linea guarda la linea que esta leyendo BufferedReader
        String linea;
        
        //Contador de lineas que contiene el texto
        int lincant = 0;
        
        //Guarda columnas
        String texto = "";
        //Guarda etiquetas de columnas (a que tabla pertenecen)
        String texto2 = "";
        String nomtab1 = "";
        String nomtab2 = "";

        //Ciclo para recorrer texto y eliminar palabras reservadas
        while ((linea = br.readLine()) != null) 
        {
            //contador de lineas
            lincant++;
            //Elimina palabra reservada ON y extrae los elementos que se encuentren 
            //entre 
            if (linea.contains(".") && linea.contains("com") && linea.contains("=") && linea.contains("ON")) 
            {
                texto = texto + " " + linea.substring(linea.indexOf(".") + 1, linea.indexOf("=") - 1) + " "
                + linea.substring(linea.lastIndexOf(".") + 1, linea.length());

                texto2 = texto2 + " " + linea.substring(3, linea.indexOf(".")) + " "
                + linea.substring(linea.indexOf("=") + 1, linea.lastIndexOf("."));
            } 
            else 
            {
                //Si la linea contiene punto pero no, se buscaran las palabras
                //reservadas "WHERE" y "ORDER" en caso de no estar se agregaran
                //A los Strings texto y texto2 lo que contenga la linea que este
                //Entre el principio y el primer punto para el texto 2
                //Y lo que este entre
                if (linea.contains(".") && !linea.endsWith(",")) 
                {
                    if (linea.contains("WHERE")) 
                    {
                        texto = texto + " " + linea.substring(linea.indexOf(".") + 1, linea.indexOf("=") - 1);
                        texto2 = texto2 + " " + linea.substring(linea.indexOf(" "), linea.indexOf("."));
                    } 
                    else 
                    {
                        if (linea.contains("ORDER")) 
                        {
                            texto = texto + " " + linea.substring(linea.indexOf(".") + 1, linea.lastIndexOf(" "));

                            texto2 = texto2 + " " + linea.substring(linea.indexOf("Y ") + 1, linea.indexOf("."));

                        } 
                        else 
                        {
                            texto2 = texto2 + " " + linea.substring(0, linea.indexOf("."));
                            texto = texto + " " + linea.substring(linea.indexOf('.') + 1, linea.length());
                        }
                    }
                } 
                else 
                {
                    //Si la linea contiene "." y ","
                    //texto guardara lo que hay despues del punto y antes de la coma
                    //texto2 guardara lo que hay del principio al punto
                    if (linea.contains(".") && linea.endsWith(",")) 
                    {
                        texto = texto + " " + linea.substring(linea.indexOf('.') + 1, linea.length() - 1);
                        texto2 = texto2 + " " + linea.substring(0, linea.indexOf("."));
                    } 
                    else
                    {
                        //Si las condiciones anteriores a este punto no se cumplieron
                        //Se buscaran palabras reservadas como FROM/SELECT o JOIN
                        //En el caso de FROM/SELECT el texto no sufre cambios
                        if (linea.equals("FROM") || linea.equals("SELECT")) 
                        {
                            texto = texto;
                        } 
                        else 
                        {
                            //Al encontrar JOIN
                            //texto sera igual a la linea menos el JOIN
                            //texto2 sera igual lo que se encuentre despues del JOIN
                            if (linea.contains("JOIN")) 
                            {
                                texto = texto + linea.replace(linea.substring(linea.lastIndexOf("J"), linea.lastIndexOf("N") + 1), "");
                                texto2 = texto2 + linea.substring(linea.indexOf(" "), linea.length());
                            } 
                            else 
                            {
                                texto = texto + " " + linea;
                                texto2 = texto2 + " " + linea;
                            }
                        }
                    }
                }       
            }
        }

        //Toknizer para texto y texto2
        //Sera utilizado para manipular contenido de ambos String
        StringTokenizer st = new StringTokenizer(texto);
        StringTokenizer st2 = new StringTokenizer(texto2);
        
        //Contar tokens para uso en tama√±o de matriz
        int tok = st.countTokens();
        int tok2 = st2.countTokens();
        String[][] textoarray = new String[2][tok2 + 1];
        
        String aux = null;

        //Se colocan etiquetas
        textoarray[0][0] = "TableName";
        textoarray[1][0] = "ColumnName";
        
        //Contador
        int c = 0;
        //Se busca el nombre de las tablas por medio de for
        for (int j = 1; j < tok; j++) 
        {
            textoarray[1][j] = st.nextToken();
            textoarray[0][j] = st2.nextToken();
            System.out.println(textoarray[0][j] + "   " + textoarray[1][j]);
            //Si los espacios de 2 casillas contiguas son iguales
            //la variable aux atrapara el String dentro de ellas y sumara 1 a c
            if (textoarray[0][j].equals(textoarray[1][j])) 
            {
                aux = textoarray[0][j];
                c++;
            }
            //si c == 1 se asignara el nombre de tabla(aux) a variable nomtab1
            if (c == 1 && textoarray[0][j].length() > 3) 
            {
                nomtab1 = aux;
            } 
            else 
            {
                //Se encuentra otra coincidencia y cuando c sea mayor a 1 (en la tercer coincidencia)
                //se habra encontrado el segundo nombre de tabla
                if (c > 1 && textoarray[0][j].length() > 3) 
                {
                    nomtab2 = aux;
                }
            }
        }
        
        //Cambiar alias por etiquetas de tablas
        for (int j = 1; j < tok; j++) 
        {
            //Si lo que hay dentro de la casilla es igual a las 3 primeras letras del nombre de tabla
            //la casilla sera igual al nombre de tabla
            if (textoarray[0][j].contains(nomtab1.substring(0, 2)) && !textoarray[1][j].contains(".")) 
            {
                    textoarray[0][j] = nomtab1;
            } 
            else 
            {
                //Si lo que hay dentro de la casilla es igual a las 3 primeras letras del nombre de tabla
                //la casilla sera igual al nombre de tabla
                if (textoarray[0][j].contains(nomtab2.substring(0, 2)) && !textoarray[1][j].contains(".")) 
                {
                    textoarray[0][j] = nomtab2;
                }
            }
        }
        
        //Ciclo para recorrer matriz
        for (int j = 0; j < tok; j++) 
        {
            //Elimina los nombres tablas cuando estan en la misma fila
            if (textoarray[0][j].equals(textoarray[1][j])) 
            {
                textoarray[0][j] = "";
                textoarray[1][j] = "";
            } 
            else 
            {
                //Elimina los alias y nombres de tablas de la matriz siempre si estan en la misma fila
                if (textoarray[1][j].length() <= 3 && textoarray[0][j].contains(textoarray[1][j])) 
                {
                    textoarray[0][j] = "";
                    textoarray[1][j] = "";
                }
            }
        }
        
        //Contadores para array
        int cont = 0;
        int cont2 = 0;
        
        //Recorrer array
        //Contara todo espacio que no este vacio
        for (int j = 0; j < tok; j++) 
        {
            if (!"".equals(textoarray[0][j])) 
            {
                cont++;
            }
        }
        
        //Declarar matriz que se utilizara en excel
        String[][] textoarrayexcel = new String[cont][cont];
        //Recorrer array
        //agregara todo valor que no este vacio al arrayexcel
        for(int j=0; j<tok; j++) 
        {
            //Contador2 para no obtener OutOfBounds usando variable j
            //contador 2 suma 1 solo cuando hay un valor diferente de ""
            if(!"".equals(textoarray[0][j])) 
            {
                textoarrayexcel[0][cont2]=textoarray[0][j];
                textoarrayexcel[1][cont2]=textoarray[1][j];

                cont2++;
            }
        }
        
        //Declarar Scanner
        Scanner leer = new Scanner(System.in);
        //Asignar nombre al archivo de excel a crear
        System.out.println("Ingrese el nombre de su hoja");
        String nomHoja = leer.next();
        
        //Creacion de String para ruta, se usa System.getProperty para que el c√≥digo funcione fuera de mi computadora (faltan pruebas)
        String ruta = "/Users/"+System.getProperty("user.name")+"/Desktop/"+nomHoja+".xls";
        g.generarExcel(textoarrayexcel,ruta,nomHoja);
    }
    
    
    
     public void generarExcel(String[][] entrada, String ruta, String nomHoja) 
     {
            try 
            {
                    WorkbookSettings conf = new WorkbookSettings();
                    conf.setEncoding("ISO-8859-1");
                    WritableWorkbook workbook = Workbook.createWorkbook(new File(ruta), conf);

                    WritableSheet sheet = workbook.createSheet(nomHoja, 0);

                    WritableFont h = new WritableFont(WritableFont.COURIER, 16, WritableFont.NO_BOLD);
                    WritableCellFormat hformat = new WritableCellFormat(h);
                    for (int i = 0; i < entrada.length; i++) {
                            for (int j = 0; j < entrada[i].length; j++) {

                                    sheet.addCell(new jxl.write.Label(i, j, entrada[i][j], hformat));

                            }
                    }

                    workbook.write();

                    workbook.close();

            } 
            catch (IOException e) 
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 
            catch (RowsExceededException e) 
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 
            catch (WriteException e) 
            {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

	}
    
}
